# üìù Relat√≥rio do Laborat√≥rio 2 - Chamadas de Sistema

---

## 1Ô∏è‚É£ Exerc√≠cio 1a - Observa√ß√£o printf() vs 1b - write()

### üíª Comandos executados:
```bash
strace -e write ./ex1a_printf
strace -e write ./ex1b_write
```

### üîç An√°lise

**1. Quantas syscalls write() cada programa gerou?**
- ex1a_printf: ___1__ syscalls
- ex1b_write: ___5__ syscalls

**2. Por que h√° diferen√ßa entre os dois m√©todos? Consulte o docs/printf_vs_write.md**

```
Ela existe pois a diferen√ßa est√° presente no buffering do I/O.
O write gera uma chamada imediata ao Kernel, n√£o tendo buffering, j√° o printf √© fun√ß√£o "padr√£o" pois vem na biblioteca padr√£o do C, o qual acumula dados no buffer.
```

**3. Qual m√©todo √© mais previs√≠vel? Por qu√™ voc√™ acha isso?**

```
Write √© mais previs√≠vel pois ele corresponde diretamente a uma chamada de sistema. O printf por usar o Buffer depende do estado do mesmo na stdio.
```

---

## 2Ô∏è‚É£ Exerc√≠cio 2 - Leitura de Arquivo

### üìä Resultados da execu√ß√£o:
- File descriptor: 3
- Bytes lidos: 134

### üîß Comando strace:
```bash
strace -e openat,read,close ./ex2_leitura
```

### üîç An√°lise

**1. Qual file descriptor foi usado? Por que n√£o come√ßou em 0, 1 ou 2?**

```
Foi usado o 3, pois o shell reserva o 0, 1 e 2 para todos os processos. Em outras palavras, o 0 e o 1 s√£o usados para entrada de teclado, e o 2 √© utilizado para exibir a sa√≠da no terminal, como quando ocorre um erro e o programa apresenta uma mensagem.

```

**2. Como voc√™ sabe que o arquivo foi lido completamente?**

```
Por conta do comportamento da chamada read(). O la√ßo criado pelo while continua rodando enqunato o read() l√™ ao menos 1 byte.
```

**3. Por que verificar retorno de cada syscall?**

```
Simples: se voc√™ n√£o fizer isso, pode acabar deixando passar erros e "perdendo" o controle sobre o gerenciamento das opera√ß√µes parciais, etc...

```
---

## 3Ô∏è‚É£ Exerc√≠cio 3 - Contador com Loop

### üìã Resultados (BUFFER_SIZE = 64):
- Linhas: 25 (esperado: 25)
- Caracteres: 700
- Chamadas read(): 11
- Tempo: ~0.000045  segundos

### üß™ Experimentos com buffer:

| Buffer Size | Chamadas read() | Tempo (s) |
|-------------|-----------------|-----------|
| 16          |       44        | ~0.000062 |
| 64          |       11        | ~0.000045 |
| 256         |        3        | ~0.000038 |
| 1024        |        1        | ~0.000035 |

Exportar para as Planilhas 

### üîç An√°lise

**1. Como o tamanho do buffer afeta o n√∫mero de syscalls?**

```
O buffer tem seu tamanho inversamente proporcional ao n√∫mero de syscalls do read(). Um buffer maior permite mais pedidos e recebimentos de dados do Kernel em uma √∫nica chamada.
```

**2. Todas as chamadas read() retornaram BUFFER_SIZE bytes? Discorra brevemente sobre**

```
N√£o. A √∫ltima chamada de um read() quase sempre retorna um valor menor que o Buffer_Size, pois o tamanho do arquivo dificilmente √© um m√∫ltiplo exato do tamanho do buffer.
```

**3. Qual √© a rela√ß√£o entre syscalls e performance?**

```
Syscalls √© uma opera√ß√£o bem cara do ponto de vista computacional, a redu√ß√£o delas √© uma das principais otimiza√ß√µes de performance, pois ele sempre for√ßa a mudan√ßa de usu√°rio para kernel.
```

---

## 4Ô∏è‚É£ Exerc√≠cio 4 - C√≥pia de Arquivo

### üìà Resultados:
- Bytes copiados: 10240000
- Opera√ß√µes: 5000
- Tempo: ~0.005123  segundos
- Throughput: 1951981.46  KB/s

### ‚úÖ Verifica√ß√£o:
```bash
diff dados/origem.txt dados/destino.txt
```
Resultado: [X] Id√™nticos [ ] Diferentes

### üîç An√°lise

**1. Por que devemos verificar que bytes_escritos == bytes_lidos?**

```
S√≥ verificando os bytes podemos garantir a integridade dos dados.
```

**2. Que flags s√£o essenciais no open() do destino?**

```
O_WRONLY; O_CREAT; O_TRUNC.
```

**3. O n√∫mero de reads e writes √© igual? Por qu√™?**

```
Pois, na c√≥pia de um disco, para cada chamada de read() √© executada uma chamada de write(), seguindo a l√≥gica de 1x1. S√≥ pode ser diferente quando h√° tratamento de escritas parciais.
```

**4. Como voc√™ saberia se o disco ficou cheio?**

```
O write() iria retornar a falha -1 e o c√≥digo ENOSPC.
```

**5. O que acontece se esquecer de fechar os arquivos?**

```
Haveria vaazmento de recursos e poderia afetar a conscitencia dos dados, levando a crash do sistema.
```

---

## üéØ An√°lise Geral

### üìñ Conceitos Fundamentais

**1. Como as syscalls demonstram a transi√ß√£o usu√°rio ‚Üí kernel?**

```
A opera√ß√£o de uma syscall √© direta, for√ßando a troca de modo. Ao utilizar o strace, essa troca se torna vis√≠vel.
```

**2. Qual √© o seu entendimento sobre a import√¢ncia dos file descriptors?**

```
Eles s√£o importantes por demonstrarem todas as fontes I/O como um n√∫mero inteiro, permitindo o read() e o write() operarem em recursos completamente distintos. 
```

**3. Discorra sobre a rela√ß√£o entre o tamanho do buffer e performance:**

```
Buffer maior = menos syscalls, melhorando a performance do sistema. S√≥ atentar que o buffer pode chegar a um ponto em que continuar aumentando s√≥ causa desperd√≠cio de mem√≥ria.
```

### ‚ö° Compara√ß√£o de Performance

```bash
# Teste seu programa vs cp do sistema
time ./ex4_copia
time cp dados/origem.txt dados/destino_cp.txt
```

**Qual foi mais r√°pido?** _____

**Por que voc√™ acha que foi mais r√°pido?**

```
O cp √© melhor: ele sempre define um buffer estupidamente grande, o que reduz o n√∫mero de syscalls e melhora a performance. Al√©m disso, o cp permite que o syscall copie dados diretamente entre dois arquivos, sem precisar trazer tudo pro espa√ßo de usu√°rio. E claro, o cp tem anos de otimiza√ß√µes (e n√£o foi feito por mim, o que j√° ajuda bastante).
```

---

## üì§ Entrega
Certifique-se de ter:
- [ ] Todos os c√≥digos com TODOs completados
- [ ] Traces salvos em `traces/`
- [ ] Este relat√≥rio preenchido como `RELATORIO.md`

```bash
strace -e write -o traces/ex1a_trace.txt ./ex1a_printf
strace -e write -o traces/ex1b_trace.txt ./ex1b_write
strace -o traces/ex2_trace.txt ./ex2_leitura
strace -c -o traces/ex3_stats.txt ./ex3_contador
strace -o traces/ex4_trace.txt ./ex4_copia
```
# Bom trabalho!
